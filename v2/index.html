
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Open Quantum Assembly Language &#8212; OpenQASM Live Specification  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="open-quantum-assembly-language">
<h1>Open Quantum Assembly Language<a class="headerlink" href="#open-quantum-assembly-language" title="Permalink to this headline">¶</a></h1>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>Software architectures, compilers, and languages specifically for
quantum computing have been studied by the academic community for more
than a decade (<a class="reference internal" href="#sel04" id="id1"><span>[Sel04]</span></a>, <a class="reference internal" href="#gay06" id="id2"><span>[Gay06]</span></a>, <a class="reference internal" href="#schc06" id="id3"><span>[SCHC06]</span></a>, <a class="reference internal" href="#hsst16" id="id4"><span>[HSST16]</span></a>) and
references therein). Researchers have implemented software and
simulators that can be used in practice to study quantum algorithms at
many scales. While we cannot survey this work here, we list a few of
these projects, several of which include software that has been made
readily available: Liquid (<a class="reference internal" href="#wesv14" id="id5"><span>[WeSv14]</span></a>, <a class="reference internal" href="#liq16" id="id6"><span>[Liq16]</span></a>), Scaffold (<a class="reference internal" href="#jpkh14" id="id7"><span>[JPKH14]</span></a>,
<a class="reference internal" href="#sca16" id="id8"><span>[Sca16]</span></a>), Quipper (<a class="reference internal" href="#vrss15" id="id9"><span>[VRSS15]</span></a>, <a class="reference internal" href="#glrs13" id="id10"><span>[GLRS13]</span></a>, <a class="reference internal" href="#qui13" id="id11"><span>[Qui13]</span></a>), ProjectQ
(<a class="reference internal" href="#stth16" id="id12"><span>[StTH16]</span></a>, <a class="reference internal" href="#prq17" id="id13"><span>[PrQ17]</span></a> ), QCL (<a class="reference internal" href="#omer03" id="id14"><span>[Omer03]</span></a>, <a class="reference internal" href="#omer98" id="id15"><span>[Omer98]</span></a>), Quiddpro
(<a class="reference internal" href="#vgmh04" id="id16"><span>[VGMH04]</span></a>, <a class="reference internal" href="#vimh05" id="id17"><span>[ViMH05]</span></a>), Chisel-q (<a class="reference internal" href="#liku13" id="id18"><span>[LiKu13]</span></a>, <a class="reference internal" href="#chi16" id="id19"><span>[Chi16]</span></a>), and Quil
(<a class="reference internal" href="#smcz16" id="id20"><span>[SmCZ16]</span></a>, <a class="reference internal" href="#quil17" id="id21"><span>[Quil17]</span></a>).</p>
<p>Our goal in this document is to describe an interface language for the
Quantum Experience that enables experiments with small depth quantum
circuits. The language can be generated by the Composer, hand-written,
or targeted by higher level software tools, such as those
above. Before we do so, we discuss quantum programs in general to
provide context.  General quantum programs require coordination of
quantum and classical parts of the computation. One way to think about
general quantum programs is to identify their distinct phases of
execution (<a class="reference internal" href="#glrs13" id="id22"><span>[GLRS13]</span></a>). <a class="reference internal" href="#blocks"><span class="std std-numref">Fig. 1</span></a> shows a high-level diagram of
the processes and abstractions involved in specifying a quantum
algorithm, transforming the algorithm into executable form, running an
experiment or simulation, and analyzing the results. A key idea
throughout these processes is the use of intermediate
representations. An intermediate representation (IR) of a computation
is neither its source language description, nor the target machine
instructions, but something in between. Compilers may use several IRs
during the process of translating and optimizing a program.</p>
</div>
<div class="section" id="compilation">
<h2>Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h2>
<p>This phase takes place on a classical computer in a setting where
specific problem parameters are not yet known and no interaction with
the quantum computer is required, i.e. it is offline.  The input is
source code describing a quantum algorithm and any compile time
parameters. The output is a combined quantum/classical program
expressed using a high level IR. During this phase, it is possible to
compile classical procedures into object code and make initial passes
that do not require complete knowledge of the problem parameters.</p>
</div>
<div class="section" id="circuit-generation">
<h2>Circuit generation<a class="headerlink" href="#circuit-generation" title="Permalink to this headline">¶</a></h2>
<p>This takes place on a classical computer in an environment where
specific problem parameters are now known, and some interaction with
the quantum computer may occur, i.e. this is an online phase. The
input is a quantum/classical program expressed using a high level IR,
as well as all remaining problem parameters. The output is a
collection of quantum circuits, or quantum basic blocks, together with
associated classical control instructions and classical object code
needed at run-time. A basic block is a straight-line code sequence
with no branches (except at the entry and exit points). Since feedback
can occur on multiple time scales, the quantum circuits may include
instructions for fast feedback. Other classical control instructions
outside of the quantum circuit basic block include, for example,
run-time parameter computations and measurement-dependent branches.
External classical object code could include algorithms to process
measurement outcomes into control flow conditions or results, or to
generate new basic blocks on the fly. The output of circuit generation
is expressed using a quantum circuit IR. Further circuit generation
may occur based on processed measurement results.</p>
</div>
<div class="section" id="execution">
<h2>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h2>
<p>This takes place on physical quantum computer controllers
in a real-time environment, i.e. the quantum computer is active. The
input is a collection of quantum circuits and associated run-time
control statements expressed using a quantum circuit IR. The input is
processed by a high-level controller into a stream of real-time
instructions in a low-level format that corresponds to physical
operations. These are executed on a low-level controller, and a
corresponding results stream provides measurement data back to the
high-level controller when needed. In general, the high level controller
(or virtual machine) can execute classical control instructions and
external object code. The output of circuit execution is a collection of
processed measurement results returned from the high-level controller.</p>
</div>
<div class="section" id="post-processing">
<h2>Post-processing<a class="headerlink" href="#post-processing" title="Permalink to this headline">¶</a></h2>
<p>This takes place on a classical computer after all
real-time processing is complete. The input is a collection of processed
measurement results, and the output is intermediate results for further
circuit generation and/or the final result of the quantum computation.</p>
<div class="figure align-default" id="blocks">
<a class="reference internal image-reference" href="_images/blocks.png"><img alt="_images/blocks.png" src="_images/blocks.png" style="width: 17.00000cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Block diagrams of processes (blue) and abstractions (red) to
transform and execute a quantum algorithm. The emphasized quantum
circuit abstraction is the main focus of this document. The API and
Resource Manager (green) represents the gateway to backend processes
for circuit execution. Dashed vertical lines separate offline,
online, and real-time processes.</span><a class="headerlink" href="#blocks" title="Permalink to this image">¶</a></p>
</div>
<p>Our model of program execution on the Quantum Experience does not allow
fully general classical computations in the loop with quantum
computations, as described above, because qubits remain coherent for a
limited time. Quantum programs are broken into distinct circuits whose
quantum outputs cannot be carried over into the next circuit. Classical
computation is done between quantum circuit executions. Users actively
participate in the circuit generation phase and manually implement part
of feedback path through the high level controller in
<a class="reference internal" href="#blocks"><span class="std std-numref">Fig. 1</span></a>, observing outcomes from the previous quantum circuit
and choosing the next quantum circuit to execute. Making use of an API
to the execution phase, users can write their own software for
compilation and circuit generation that interacts with the hardware over
a sequence of quantum circuit executions. After obtaining all of the
processed results, users may post-process the data offline.</p>
<p>We specify part of a quantum circuit intermediate representation based
on the quantum circuit model, a standard formalism for quantum
computation (<a class="reference internal" href="#nich00" id="id23"><span>[NiCh00]</span></a>). The quantum circuit abstraction
is emphasized in <a class="reference internal" href="#blocks"><span class="std std-numref">Fig. 1</span></a>. The IR expresses quantum circuits
with fast feedback, such as might constitute the basic blocks of a
full-featured IR. A basic block is a straight-line code sequence with no
branches (except at the entry and exit points). We have chosen to
include statements that are essential for near-term experiments and that
we believe will be present in any future IR. The representation will be
quite familiar to experts.</p>
<p>The human-readable form of our quantum circuit IR is based on “quantum
assembly language” (<a class="reference internal" href="#chu05" id="id24"><span>[Chu05]</span></a>, <a class="reference internal" href="#cro05" id="id25"><span>[Cro05]</span></a>, <a class="reference internal" href="#schc06" id="id26"><span>[SCHC06]</span></a>, <a class="reference internal" href="#bako05" id="id27"><span>[BaKO05]</span></a>,
<a class="reference internal" href="#dosp16" id="id28"><span>[DoSP16]</span></a>) or QASM (pronounced <em>kazm</em>). QASM is a simple text language
that describes generic quantum circuits. QASM can represent a
completely “unrolled” quantum program whose parameters have all been
specified.  Most QASM variants assume a discrete set of quantum gates,
but our IR is designed to control a physical system with a
parameterized gate set.  While we use the term “quantum assembly
language”, this is merely an analogy and should not be taken too far.</p>
<p>Open QASM represents universal physical circuits, so we propose a
built-in gate basis of arbitrary single-qubit gates and a two-qubit
entangling gate (CNOT) <a class="reference internal" href="#bbcd95" id="id29"><span>[BBCD95]</span></a>. We choose a simple language without
higher level programming primitives. We define different gate sets
using a subroutine-like mechanism that hierarchically specifies new
unitary gates in terms of built-in gates and previously defined gate
subroutines. In this way, the built-in basis is used to define
hardware-supported operations via standard header files. The
subroutine mechanism allows limited code reuse by hierarchically
defining more complex operations (<a class="reference internal" href="#jpkh14" id="id30"><span>[JPKH14]</span></a>; <a class="reference internal" href="#dosp16" id="id31"><span>[DoSP16]</span></a>). We also add
instructions that model a quantum-classical interface, specifically
measurement, state reset, and the most elemental classical feedback.</p>
<p>The remaining sections of this document specify Open QASM and provide
examples.</p>
</div>
<div class="section" id="language">
<span id="section-language"></span><h2>Language<a class="headerlink" href="#language" title="Permalink to this headline">¶</a></h2>
<p>The syntax of the human-readable form of Open QASM has elements of C
and assembly languages. The first (non-comment) line of an Open QASM
program must be <code class="code docutils literal notranslate"><span class="pre">OPENQASM</span> <span class="pre">M.m;</span></code> indicating a major version M and
minor version m.  Version 2.0 is described in this document. The
version keyword cannot occur multiple times in a file. Statements are
separated by semicolons.  Whitespace is ignored. The language is case
sensitive. Comments begin with a pair of forward slashes and end with
a new line. The statement <code class="code docutils literal notranslate"><span class="pre">include</span> <span class="pre">“filename”;</span></code> continues parsing
filename as if the contents of the file were pasted at the location of
the include statement. The path is specified relative to the current
working directory.</p>
<p>The only storage types of Open QASM (version 2.0) are classical and
quantum registers, which are one-dimensional arrays of bits and
qubits, respectively. The statement <code class="code docutils literal notranslate"><span class="pre">qreg</span> <span class="pre">name[size];</span></code> declares
an array of qubits (quantum register) with the given name and
size. Identifiers, such as name, must start with a lowercase letter
and can contain alpha-numeric characters and underscores. The label
name[j] refers to a qubit of this register, where <span class="math notranslate nohighlight">\(j\in
\{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}\)</span>. The qubits are
initialized to <span class="math notranslate nohighlight">\(|0\rangle\)</span>. Likewise, <code class="code docutils literal notranslate"><span class="pre">creg</span> <span class="pre">name[size];</span></code>
declares an array of bits (register) with the given name and size. The
label <code class="code docutils literal notranslate"><span class="pre">name[j]</span></code> refers to a bit of this register, where
<span class="math notranslate nohighlight">\(j\in \{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}\)</span>. The bits
are initialized to <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="figure align-default" id="builtin-twoqubit-gates">
<a class="reference internal image-reference" href="_images/builtin_twoqubit_gates.png"><img alt="_images/builtin_twoqubit_gates.png" src="_images/builtin_twoqubit_gates.png" style="width: 17.00000cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">The built-in two-qubit entangling gate is the controlled-NOT
gate. If a and b are qubits, the statement <code class="code docutils literal notranslate"><span class="pre">CX</span> <span class="pre">a,b;</span></code> applies
a controlled-NOT (CNOT) gate that flips the target qubit b iff the
control qubit a is one. If a and b are quantum registers, the
statement applies CNOT gates between corresponding qubits of each
register. There is a similar meaning when a is a qubit and b is a
quantum register and vice versa.</span><a class="headerlink" href="#builtin-twoqubit-gates" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id40">
<span id="single-qubit-unitaries"></span><a class="reference internal image-reference" href="_images/single_qubit_unitaries.png"><img alt="_images/single_qubit_unitaries.png" src="_images/single_qubit_unitaries.png" style="width: 12cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">The single-qubit unitary gates are built in. These gates are
parameterized by three real parameters θ, φ, and λ. If the argument q
is a quantum register, the statement applies size(q) gates in parallel
to the qubits of the register.</span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</div>
<p>The built-in universal gate basis is “CNOT + <span class="math notranslate nohighlight">\(U(2)\)</span>”. There is one
built-in two-qubit gate (<a class="reference internal" href="#builtin-twoqubit-gates"><span class="std std-numref">Fig. 2</span></a>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{CNOT} := \left(\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \end{array}\right)\end{split}\]</div>
<p>called the controlled-NOT gate. The statement <code class="code docutils literal notranslate"><span class="pre">CX</span> <span class="pre">a,b;</span></code> applies
a CNOT gate that flips the target qubit b if and only if the control
qubit a is one. The arguments cannot refer to the same qubit. Built-in
gates have reserved uppercase keywords. If a and b are quantum
registers <em>with the same size</em>, the statement means apply <code class="code docutils literal notranslate"><span class="pre">CX</span>
<span class="pre">a[j],</span> <span class="pre">b[j];</span></code> for each index j into register a. If instead, a is a
qubit and b is a quantum register, the statement means apply <code class="code docutils literal notranslate"><span class="pre">CX</span>
<span class="pre">a,</span> <span class="pre">b[j];</span></code> for each index j into register b.  Finally, if a is a
quantum register and b is a qubit, the statement means apply <code class="code docutils literal notranslate"><span class="pre">CX</span>
<span class="pre">a[j],</span> <span class="pre">b;</span></code> for each index j into register a.</p>
<p>All of the single-qubit unitary gates are also built in
(<a class="reference internal" href="#single-qubit-unitaries"><span class="std std-numref">Fig. 3</span></a>) and parameterized as</p>
<div class="math notranslate nohighlight">
\[\begin{split}U(\theta,\phi,\lambda) := R_z(\phi)R_y(\theta)R_z(\lambda) = \left(\begin{array}{cc}
e^{-i(\phi+\lambda)/2}\cos(\theta/2) &amp; -e^{-i(\phi-\lambda)/2}\sin(\theta/2) \\
e^{i(\phi-\lambda)/2}\sin(\theta/2) &amp; e^{i(\phi+\lambda)/2}\cos(\theta/2)
\end{array}\right).\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(R_y(\theta)=\mathrm{exp}(-i\theta Y/2)\)</span> and
<span class="math notranslate nohighlight">\(R_z(\phi)=\mathrm{exp}(-i\phi Z/2)\)</span>. This specifies any
element of <span class="math notranslate nohighlight">\(SU(2)\)</span>. When a is a quantum register, the statement
<code class="code docutils literal notranslate"><span class="pre">U(theta,phi,lambda)</span> <span class="pre">a;</span></code> means apply <code class="code docutils literal notranslate"><span class="pre">U(theta,phi,lambda)</span>
<span class="pre">a[j];</span></code> for each index j into register a. The real parameters
<span class="math notranslate nohighlight">\(\theta\in [0,4\pi)\)</span>, <span class="math notranslate nohighlight">\(\phi\in [0,4\pi)\)</span>, and
<span class="math notranslate nohighlight">\(\lambda\in [0,4\pi)\)</span> are given by <em>parameter expressions</em>
constructed using in-fix notation. These support scientific calculator
features with arbitrary precision real numbers <a class="footnote-reference brackets" href="#id39" id="id32">1</a>. For example,
<code class="code docutils literal notranslate"><span class="pre">U(pi/2,0,pi)</span> <span class="pre">q[0];</span></code> applies a Hadamard gate to qubit q[0]. Open QASM
(version 2.0) does not provide a mechanism for computing parameters
based on measurement outcomes.</p>
<p>New gates can be defined as unitary subroutines using the built-in
gates, as shown in <a class="reference internal" href="#composite-gate"><span class="std std-numref">Fig. 4</span></a>. These can be viewed as
macros whose expansion we defer until run-time. Gates are defined by
statements of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// comment</span>
<span class="n">gate</span> <span class="nf">name</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="n">qargs</span>
<span class="p">{</span>
        <span class="n">body</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where the optional parameter list params is a comma-separated list of
variable parameter names, and the argument list qargs is a
comma-separated list of qubit arguments. Both the parameter names and
qubit arguments are identifiers. If there are no variable parameters,
the parentheses are optional. At least one qubit argument is required.
The first comment may contain documentation, such as TeX markup, to be
associated with the gate. The arguments in qargs cannot be indexed
within the body of the gate definition.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// this is ok:</span>
<span class="n">gate</span> <span class="n">g</span> <span class="n">a</span>
<span class="p">{</span>
        <span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// this is invalid:</span>
<span class="n">gate</span> <span class="n">g</span> <span class="n">a</span>
<span class="p">{</span>
        <span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Only built-in gate statements, calls to previously defined gates, and
barrier statements can appear in body. The statements in the body can
only refer to the symbols given in the parameter or argument list, and
these symbols are scoped only to the subroutine body. An empty body
corresponds to the identity gate. Subroutines must be declared before
use and cannot call themselves. The statement <code class="code docutils literal notranslate"><span class="pre">name(params)</span>
<span class="pre">qargs;</span></code> applies the subroutine, and the variable parameters params are
given as parameter expressions. The gate can be applied to any
combination of qubits and quantum registers <em>of the same size</em> as
shown in the following example. The quantum circuit given by</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gate</span> <span class="n">g</span> <span class="n">qb0</span><span class="p">,</span><span class="n">qb1</span><span class="p">,</span><span class="n">qb2</span><span class="p">,</span><span class="n">qb3</span>
<span class="p">{</span>
        <span class="c1">// body</span>
<span class="p">}</span>
<span class="n">qreg</span> <span class="n">qr0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">qreg</span> <span class="n">qr1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">qreg</span> <span class="n">qr2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">qreg</span> <span class="n">qr3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">g</span> <span class="n">qr0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qr1</span><span class="p">,</span><span class="n">qr2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qr3</span><span class="p">;</span> <span class="c1">// ok</span>
<span class="n">g</span> <span class="n">qr0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qr2</span><span class="p">,</span><span class="n">qr1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qr3</span><span class="p">;</span> <span class="c1">// error!</span>
</pre></div>
</div>
<p>has a second-to-last line that means</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nv">j</span> <span class="o">=</span> <span class="m">0</span>, <span class="m">1</span> <span class="k">do</span>
               g qr0<span class="o">[</span><span class="m">0</span><span class="o">]</span>,qr1<span class="o">[</span>j<span class="o">]</span>,qr2<span class="o">[</span><span class="m">0</span><span class="o">]</span>,qr3<span class="o">[</span>j<span class="o">]</span><span class="p">;</span>
</pre></div>
</div>
<p>We provide this so that user-defined gates can be applied in parallel
like the built-in gates.</p>
<div class="figure align-default" id="composite-gate">
<a class="reference internal image-reference" href="_images/composite_gate.png"><img alt="_images/composite_gate.png" src="_images/composite_gate.png" style="width: 15.00000cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">New gates are defined as unitary subroutines. The gates are applied
using the statement <code class="code docutils literal notranslate"><span class="pre">name(params)</span> <span class="pre">qargs;</span></code> just like the
built-in gates. The parentheses are optional if there are no
parameters. The gate cu1(θ) corresponds to the unitary matrix
diag(1, 1, 1, <span class="math notranslate nohighlight">\(e^{iθ}\)</span> ) up to a global phase.</span><a class="headerlink" href="#composite-gate" title="Permalink to this image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gate</span> <span class="nf">cu1</span><span class="p">(</span><span class="n">lambda</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span>
<span class="p">{</span>
        <span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">lambda</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">CX</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
        <span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">lambda</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">CX</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
        <span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">lambda</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cu1</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div>
</div>
<p>To support gates whose physical implementation may be possible, but
whose definition is unspecified, we provide an “opaque” gate
declaration. This may be used in practice in several instances. For
example, the system may evolve under some fixed but uncharacterized
drift Hamiltonian for some fixed amount of time. The system might be
subject to an <span class="math notranslate nohighlight">\(n\)</span>-qubit operator whose parameters are
computationally challenging to estimate. The syntax for an opaque gate
declaration is the same as a gate declaration but without a body.</p>
<p>Measurement is shown in <a class="reference internal" href="#measure-statement"><span class="std std-numref">Fig. 5</span></a>. The statement
<code class="code docutils literal notranslate"><span class="pre">measure</span> <span class="pre">qubit|qreg</span> <span class="pre">-&gt;</span> <span class="pre">bit|creg;</span></code> measures the qubit(s) in the
<span class="math notranslate nohighlight">\(Z\)</span>-basis and records the measurement outcome(s) by overwriting
the bit(s).  Measurement corresponds to a projection onto one of the
eigenstates of <span class="math notranslate nohighlight">\(Z\)</span>, and qubit(s) are immediately available for
further quantum computation. Both arguments must be register-type, or
both must be bit-type. If both arguments are register-type and have
the same size, the statement <code class="code docutils literal notranslate"><span class="pre">measure</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b;</span></code> means apply measure a[j]
<span class="math notranslate nohighlight">\(\rightarrow\)</span> b[j] for each index j into register a.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">reset</span> <span class="pre">qubit|qreg;</span></code> statement resets a qubit or quantum register to
the state <span class="math notranslate nohighlight">\(|0\rangle\)</span>. This corresponds to a partial trace over
those qubits (i.e. discarding them) before replacing them with
<span class="math notranslate nohighlight">\(|0\rangle\langle 0|\)</span>, as shown in <a class="reference internal" href="#reset-statement"><span class="std std-numref">Fig. 7</span></a>.</p>
<div class="figure align-default" id="measure-statement">
<a class="reference internal image-reference" href="_images/measure_statement.png"><img alt="_images/measure_statement.png" src="_images/measure_statement.png" style="width: 17.00000cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">The measure statement projectively measures a qubit or each qubit
of a quantum register. The measurement projects onto the Z-basis
and leaves qubits available for further operations. The top row of
circuits depicts single-qubit measurement using the statement
<code class="code docutils literal notranslate"><span class="pre">measure</span> <span class="pre">q[0]</span> <span class="pre">-&gt;</span> <span class="pre">c[0];</span></code> while the bottom depicts measurement
of an entire register using the statement <code class="code docutils literal notranslate"><span class="pre">measure</span> <span class="pre">q</span> <span class="pre">-&gt;</span> <span class="pre">c;</span></code>. The
center circuit of the top row depicts measurement as the final
operation on q[0].</span><a class="headerlink" href="#measure-statement" title="Permalink to this image">¶</a></p>
</div>
<p>There is one type of classically-controlled quantum operation: the
<code class="code docutils literal notranslate"><span class="pre">if</span></code> statement shown in <a class="reference internal" href="#if-statement"><span class="std std-numref">Fig. 6</span></a>. The <code class="code docutils literal notranslate"><span class="pre">if</span></code>
statement conditionally executes a quantum operation based on the
value of a classical register.  This allows measurement outcomes to
determine future quantum operations.  We choose to have one decision
register for simplicity. This register is interpreted as an integer,
using the bit at index zero as the low order bit. The quantum
operation executes only if the register has the given integer
value. Only quantum operations, i.e. built-in gates, gate (and
opaque) subroutines, preparation, and measurement, can be prefaced
by <code class="code docutils literal notranslate"><span class="pre">if</span></code>. A quantum program with a parameter that depends on values
that are known only at run-time can be rewritten using a sequence of
<code class="code docutils literal notranslate"><span class="pre">if</span></code> statements. Specifically, for a single-parameter gate with
<span class="math notranslate nohighlight">\(n\)</span> bits of precision, we may choose to write <span class="math notranslate nohighlight">\(2^n\)</span>
statements, only one of which is executed, or we can decompose the
parameterized gate into a sequence of <span class="math notranslate nohighlight">\(n\)</span> conditional gates.</p>
<div class="figure align-default" id="if-statement">
<a class="reference internal image-reference" href="_images/if_statement.png"><img alt="_images/if_statement.png" src="_images/if_statement.png" style="width: 11.0cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">The <code class="code docutils literal notranslate"><span class="pre">if</span></code> statement applies a quantum operation only if a classical
register has the indicated integer value. These circuits depict the
statement <code class="code docutils literal notranslate"><span class="pre">if(c==3)</span> <span class="pre">U(theta,</span> <span class="pre">phi,</span> <span class="pre">lambda)</span> <span class="pre">q[0];</span></code>.</span><a class="headerlink" href="#if-statement" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="reset-statement">
<a class="reference internal image-reference" href="_images/reset_statement.png"><img alt="_images/reset_statement.png" src="_images/reset_statement.png" style="width: 15.0cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">The <code class="code docutils literal notranslate"><span class="pre">reset</span></code> statement prepares a qubit or quantum register in the
state <span class="math notranslate nohighlight">\(|0\rangle\)</span>.</span><a class="headerlink" href="#reset-statement" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">barrier</span></code> instruction prevents optimizations from reordering gates
across its source line. For example,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">CX</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">h</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">h</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">barrier</span> <span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">h</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">CX</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">CX</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div>
</div>
<p>will prevent an attempt to combine the CNOT gates but will allow the
pair of <code class="code docutils literal notranslate"><span class="pre">h</span> <span class="pre">s[0];</span></code> gates to cancel.</p>
<p>Open QASM statements are summarized in
<a class="reference internal" href="#table-qasm-statements"><span class="std std-numref">Table 1</span></a>. The grammar is presented in
<a class="reference internal" href="#appendix-grammar"><span class="std std-ref">Open QASM Grammar</span></a>.</p>
<table class="docutils align-default" id="table-qasm-statements">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Open QASM language statements (version 2.0)</span><a class="headerlink" href="#table-qasm-statements" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 44%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Statement</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OPENQASM 2.0;</p></td>
<td><p>Denotes a file in Open QASM format</p></td>
<td><p>OPENQASM 2.0;</p></td>
</tr>
<tr class="row-odd"><td><p>qreg name[size];</p></td>
<td><p>Declare a named register of qubits</p></td>
<td><p>qreg q[5];</p></td>
</tr>
<tr class="row-even"><td><p>creg name[size];</p></td>
<td><p>Declare a named register of bits</p></td>
<td><p>creg c[5];</p></td>
</tr>
<tr class="row-odd"><td><p>include “filename”;</p></td>
<td><p>Open and parse another source file</p></td>
<td><p>include “qelib1.inc”;</p></td>
</tr>
<tr class="row-even"><td><p>gate name(params) qargs</p></td>
<td><p>Declare a unitary gate</p></td>
<td><p>(see text)</p></td>
</tr>
<tr class="row-odd"><td><p>opaque name(params) qargs;</p></td>
<td><p>Declare an opaque gate</p></td>
<td><p>(see text)</p></td>
</tr>
<tr class="row-even"><td><p>// comment text</p></td>
<td><p>Comment a line of text</p></td>
<td><p>// oops!</p></td>
</tr>
<tr class="row-odd"><td><p>U(theta,phi,lambda) qubit|qreg;</p></td>
<td><p>Apply built-in single qubit gate(s)</p></td>
<td><p>U(pi/2,2*pi/3,0) q[0];</p></td>
</tr>
<tr class="row-even"><td><p>CX qubit|qreg,qubit|qreg;</p></td>
<td><p>Apply built-in CNOT gate(s)</p></td>
<td><p>CX q[0],q[1];</p></td>
</tr>
<tr class="row-odd"><td><p>measure qubit|qreg -&gt; bit|creg;</p></td>
<td><p>Make measurement(s) in <span class="math notranslate nohighlight">\(Z\)</span> basis</p></td>
<td><p>measure q -&gt; c;</p></td>
</tr>
<tr class="row-even"><td><p>reset qubit|qreg;</p></td>
<td><p>Prepare qubit(s) in <span class="math notranslate nohighlight">\(|0\rangle\)</span></p></td>
<td><p>reset q[0];</p></td>
</tr>
<tr class="row-odd"><td><p>gatename(params) qargs;</p></td>
<td><p>Apply a user-defined unitary gate</p></td>
<td><p>crz(pi/2) q[1],q[0];</p></td>
</tr>
<tr class="row-even"><td><p>if(creg==int) qop;</p></td>
<td><p>Conditionally apply quantum operation</p></td>
<td><p>if(c==5) CX q[0],q[1];</p></td>
</tr>
<tr class="row-odd"><td><p>barrier qargs;</p></td>
<td><p>Prevent transformations across this source line</p></td>
<td><p>barrier q[0],q[1];</p></td>
</tr>
</tbody>
</table>
<p>This must appear as the first non-comment line of the file.</p>
<p>The parameters theta, phi, and lambda are given by <em>parameter
expressions</em>; see text and <a class="reference internal" href="#appendix-grammar"><span class="std std-ref">Open QASM Grammar</span></a>.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This section gives several examples of quantum circuits expressed in
Open QASM (version 2.0). The circuits use a gate basis defined for the
Quantum Experience.</p>
<div class="section" id="quantum-experience-standard-header">
<h3>Quantum Experience standard header<a class="headerlink" href="#quantum-experience-standard-header" title="Permalink to this headline">¶</a></h3>
<p>The Quantum Experience standard header defines the gates that are
implemented by the hardware, gates that appear in the Quantum Experience
composer, and a hierarchy of additional user-defined gates. Our approach
is to define physical gates that the hardware implements in terms of the
abstract gates U and CX. The current physical gates supported by the
Quantum Experience are a superset of the abstract gates, but this is not
true of all physical gate sets and devices. Choosing to use abstract
gates merely to define physical gates gives some flexibility to add or
change physical gates at a later time without changing Open QASM. We
believe this approach is preferable to invisibly compiling abstract
gates to physical gates or to changing the underlying set of abstract
gates whenever the hardware changes.</p>
<p>The Quantum Experience currently implements the controlled-NOT gate via
the cross-resonance interaction and implements three distinct types of
single-qubit gates. The one-parameter gate</p>
<div class="math notranslate nohighlight">
\[u_1(\lambda) := \mathrm{diag}(1,e^{i\lambda}) \sim U(0,0,\lambda) = R_z(\lambda)\]</div>
<p>changes the phase of a carrier without applying any pulses. The symbol
“<span class="math notranslate nohighlight">\(\sim\)</span>” denotes equivalence up to a global phase. The gate</p>
<div class="math notranslate nohighlight">
\[u_2(\phi,\lambda) := U(\pi/2,\phi,\lambda) = R_z(\phi+\frac{\pi}{2})R_x(\pi/2)R_z(\lambda-\frac{\pi}{2})\]</div>
<p>uses a single <span class="math notranslate nohighlight">\(\pi/2\)</span>-pulse. The most general single-qubit gate</p>
<div class="math notranslate nohighlight">
\[u_3(\theta,\phi,\lambda) := U(\theta,\phi,\lambda) = R_z(\phi+3\pi)R_x(\pi/2)R_z(\theta+\pi)R_x(\pi/2)R_z(\lambda)\]</div>
<p>uses a pair of <span class="math notranslate nohighlight">\(\pi/2\)</span>-pulses.</p>
</div>
<div class="section" id="quantum-teleportation">
<h3>Quantum teleportation<a class="headerlink" href="#quantum-teleportation" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="teleport">
<img alt="_images/teleport.png" src="_images/teleport.png" />
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Example of quantum teleportation. Qubit q[0] is prepared by
<code class="code docutils literal notranslate"><span class="pre">U(0.3,0.2,0.1)</span> <span class="pre">q[0];</span></code> and teleported to q[2].</span><a class="headerlink" href="#teleport" title="Permalink to this image">¶</a></p>
</div>
<p>Quantum teleportation (<a class="reference internal" href="#teleport"><span class="std std-numref">Fig. 8</span></a>) demonstrates
conditional application of future gates based on prior measurement
outcomes.</p>
</div>
<div class="section" id="quantum-fourier-transform">
<h3>Quantum Fourier transform<a class="headerlink" href="#quantum-fourier-transform" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="fft4q">
<img alt="_images/fft4q.png" src="_images/fft4q.png" />
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Example of a 4-qubit quantum Fourier transform. The circuit applies
the QFT to <span class="math notranslate nohighlight">\(|1010\rangle\)</span> and measures in the computational
basis. The output is read in reverse order c[3], c[2], c[1], c[0].</span><a class="headerlink" href="#fft4q" title="Permalink to this image">¶</a></p>
</div>
<p>The quantum Fourier transform (QFT, <a class="reference internal" href="#fft4q"><span class="std std-numref">Fig. 9</span></a>) demonstrates
parameter passing to gate subroutines. This circuit applies the QFT to
the state <span class="math notranslate nohighlight">\(|q_0 q_1 q_2 q_3\rangle=|1010\rangle\)</span> and measures in
the computational basis.</p>
</div>
<div class="section" id="inverse-qft-followed-by-measurement">
<h3>Inverse QFT followed by measurement<a class="headerlink" href="#inverse-qft-followed-by-measurement" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="ifft4q">
<img alt="_images/ifft4q.png" src="_images/ifft4q.png" />
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Example of a 4-qubit inverse quantum Fourier transform followed by
mea- surement. In this case, the measurement commutes with the
controls of the cu1 gates and can be rewritten as shown (see Figure
3.3 in <a class="reference internal" href="#mer07" id="id33"><span>[Mer07]</span></a>). The circuit applies the inverse QFT to the uniform
superposition and measures in the computational basis.</span><a class="headerlink" href="#ifft4q" title="Permalink to this image">¶</a></p>
</div>
<p>If the qubits are all measured after the inverse QFT, the measurement
commutes with the controls of the cu1 gates, and those gates can be
replaced by classically-controlled single qubit rotations (see for
example Figure 3.3 in <a class="reference internal" href="#mer07" id="id34"><span>[Mer07]</span></a>). The example demonstrates how to
implement this classical control using conditional gates.</p>
<p>Alternatively, we can decompose the rotations and apply them using fewer
statements but more quantum gates. The corresponding circuit for this
example is shown in <a class="reference internal" href="#ifft4q"><span class="std std-numref">Fig. 10</span></a>.</p>
</div>
<div class="section" id="ripple-carry-adder">
<h3>Ripple-carry adder<a class="headerlink" href="#ripple-carry-adder" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="ripple-adder">
<img alt="_images/ripple_adder.png" src="_images/ripple_adder.png" />
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">Example of a quantum ripple-carry adder from <a class="reference internal" href="#cdkm04" id="id35"><span>[CDKM04]</span></a>. This circuit
prepares a = 1, b = 15 and computes the sum into b with an output
carry cout[0].</span><a class="headerlink" href="#ripple-adder" title="Permalink to this image">¶</a></p>
</div>
<p>The ripple-carry adder <a class="reference internal" href="#cdkm04" id="id36"><span>[CDKM04]</span></a> (Cuccaro et al. 2004) shown in
<a class="reference internal" href="#ripple-adder"><span class="std std-numref">Fig. 11</span></a> exhibits hierarchical use of gate subroutines.</p>
</div>
<div class="section" id="randomized-benchmarking">
<h3>Randomized benchmarking<a class="headerlink" href="#randomized-benchmarking" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="rb2q">
<img alt="_images/rb2q.png" src="_images/rb2q.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Example of a two-qubit randomized benchmarking (RB) sequence over
the basis hH, S, CZ, X, Y, Zi. Barriers separate the implementations
of each Clifford gate. An RB experiment consists of many
sequences. Each sequence runs some number of times (“shots”).</span><a class="headerlink" href="#rb2q" title="Permalink to this image">¶</a></p>
</div>
<p>A complete randomized benchmarking experiment could be described by a
high level program. After passing through the upper phases of
compilation, the program consists of many quantum circuits and
associated classical control. Benchmarking is a particularly simple
example because there is no data dependence between these quantum
circuits.</p>
<p>Each circuit is a sequence of random Clifford gates composed from a set
of basic gates (<a class="reference internal" href="#rb2q"><span class="std std-numref">Fig. 12</span></a> uses the gate set h, s, cz, and
Paulis). If the gate set differs from the built-in gate set, new gates
can be defined using the gate statement. Each of the randomly-chosen
Clifford gates is separated from prior and future gates by barrier
instructions to prevent the sequence from simplifying to the identity as
a result of subsequent transformations.</p>
</div>
<div class="section" id="quantum-process-tomography">
<h3>Quantum process tomography<a class="headerlink" href="#quantum-process-tomography" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="tomography1q">
<img alt="_images/tomography1q.png" src="_images/tomography1q.png" />
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Example of a single-qubit quantum process tomography circuit. The
pre and post gates are described by a higher-level program that
generates intermediate code containing several independent
circuits. Each circuit is executed some number of times (“shots”) to
compute statistics from which the h gate process is
reconstructed. Barriers separate the process under study from the pre-
and post- gates.</span><a class="headerlink" href="#tomography1q" title="Permalink to this image">¶</a></p>
</div>
<p>As in randomized benchmarking, a high-level program describes a quantum
process tomography (QPT) experiment. Each program compiles to
intermediate code with several independent quantum circuits that can
each be described using Open QASM (version 2.0). <a class="reference internal" href="#tomography1q"><span class="std std-numref">Fig. 13</span></a>
shows QPT of a Hadamard gate. Each circuit is identical except for the
definitions of the pre and post gates. The empty definitions in the
current example are placeholders that define identity gates. For
textbook QPT, the pre and post gates are both taken from the set
<span class="math notranslate nohighlight">\(\{I,H,SH\}\)</span> to prepare <span class="math notranslate nohighlight">\(|0\rangle\)</span>, <span class="math notranslate nohighlight">\(|+\rangle\)</span>, and
<span class="math notranslate nohighlight">\(|+i\rangle\)</span> and measure in the <span class="math notranslate nohighlight">\(Z\)</span>, <span class="math notranslate nohighlight">\(X\)</span>, and
<span class="math notranslate nohighlight">\(Y\)</span> basis.</p>
</div>
<div class="section" id="quantum-error-correction">
<h3>Quantum error-correction<a class="headerlink" href="#quantum-error-correction" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="bit-flip-repetition-code">
<img alt="_images/bit_flip_repetition_code.png" src="_images/bit_flip_repetition_code.png" />
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Example of a quantum bit-flip repetition code. The circuit begins
with the (classical) encoded state <span class="math notranslate nohighlight">\(|000\rangle\)</span>, applies an
error on q[0], and uses feedback on a syndrome measurement to
correct the error.</span><a class="headerlink" href="#bit-flip-repetition-code" title="Permalink to this image">¶</a></p>
</div>
<p>This example of the 3-bit quantum repetition code
(<a class="reference internal" href="#bit-flip-repetition-code"><span class="std std-numref">Fig. 14</span></a>) demonstrates how Open QASM
(version 2.0) can express simple quantum error-correction circuits.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>This document represents ideas and contributions from the IBM Quantum
Computing group as a whole. We acknowledge suggestions and discussions
with the IBM Quantum Experience community (<a class="reference internal" href="#iqe16" id="id37"><span>[IQE16]</span></a>). We thank Abigail
Cross for typesetting the figures and proof-reading the document. We
thank Tom Draper and Sandy Kutin for the
<span class="math notranslate nohighlight">\(\langle\mathrm{q}|\mathrm{pic}\rangle\)</span> package (<a class="reference internal" href="#daku16" id="id38"><span>[DaKu16]</span></a>),
which was used for initial typesetting of the quantum circuits.  We
acknowledge partial support from the IBM Research Frontiers Institute.</p>
</div>
<div class="section" id="open-qasm-grammar">
<span id="appendix-grammar"></span><h2>Open QASM Grammar<a class="headerlink" href="#open-qasm-grammar" title="Permalink to this headline">¶</a></h2>
<pre>
<strong id="grammar-token-mainprogram">mainprogram</strong> ::=  &quot;OPENQASM&quot; real &quot;;&quot; program
<strong id="grammar-token-program">program    </strong> ::=  statement | program statement
<strong id="grammar-token-statement">statement  </strong> ::=  decl
                | gatedecl goplist }
                | gatedecl }
                | &quot;opaque&quot; id idlist &quot;;&quot;
                | &quot;opaque&quot; id &quot;( )&quot; idlist &quot;;&quot;
                | &quot;opaque&quot; id &quot;(&quot; idlist &quot;)&quot; idlist &quot;;&quot;
                | qop
                | &quot;if (&quot; id &quot;==&quot; nninteger &quot;)&quot; qop
                | &quot;barrier&quot; anylist &quot;;&quot;
<strong id="grammar-token-decl">decl       </strong> ::=  &quot;qreg&quot; id [ nninteger ] &quot;;&quot; | &quot;creg&quot; id [ nninteger ] &quot;;&quot;
<strong id="grammar-token-gatedecl">gatedecl   </strong> ::=  &quot;gate&quot; id idlist {
                | &quot;gate&quot; id &quot;( )&quot; idlist {
                | &quot;gate&quot; id &quot;(&quot; idlist &quot;)&quot; idlist {
<strong id="grammar-token-goplist">goplist    </strong> ::=  uop
                | &quot;barrier&quot; idlist &quot;;&quot;
                | goplist uop
                | goplist &quot;barrier&quot; idlist &quot;;&quot;
<strong id="grammar-token-qop">qop        </strong> ::=  uop
                | &quot;measure&quot; argument &quot;-&gt;&quot; argument &quot;;&quot;
                | &quot;reset&quot; argument &quot;;&quot;
<strong id="grammar-token-uop">uop        </strong> ::=  &quot;U (&quot; explist &quot;)&quot; argument &quot;;&quot;
                | &quot;CX&quot; argument &quot;,&quot; argument &quot;;&quot;
                | id anylist &quot;;&quot; | id &quot;( )&quot; anylist &quot;;&quot;
                | id &quot;(&quot; explist &quot;)&quot; anylist &quot;;&quot;
<strong id="grammar-token-anylist">anylist    </strong> ::=  idlist | mixedlist
<strong id="grammar-token-idlist">idlist     </strong> ::=  id | idlist &quot;,&quot; id
<strong id="grammar-token-mixedlist">mixedlist  </strong> ::=  id [ nninteger ] | mixedlist &quot;,&quot; id
                | mixedlist &quot;,&quot; id [ nninteger ]
                | idlist &quot;,&quot; id [ nninteger ]
<strong id="grammar-token-argument">argument   </strong> ::=  id | id [ nninteger ]
<strong id="grammar-token-explist">explist    </strong> ::=  exp | explist &quot;,&quot; exp
<strong id="grammar-token-exp">exp        </strong> ::=  real | nninteger | &quot;pi&quot; | id
                | exp + exp | exp - exp | exp * exp
                | exp / exp | -exp | exp ^ exp
                | &quot;(&quot; exp &quot;)&quot; | unaryop &quot;(&quot; exp &quot;)&quot;
<strong id="grammar-token-unaryop">unaryop    </strong> ::=  &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;exp&quot; | &quot;ln&quot; | &quot;sqrt&quot;
</pre>
<p>This is a simplified grammar for Open QASM presented in Backus-Naur
form. The unlisted productions <span class="math notranslate nohighlight">\(\langle\mathrm{id}\rangle\)</span>,
<span class="math notranslate nohighlight">\(\langle\mathrm{real}\rangle\)</span> and
<span class="math notranslate nohighlight">\(\langle\mathrm{nninteger}\rangle\)</span> are defined by the regular
expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>id        := [a-z][A-Za-z0-9_]*
real      := ([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([eE][-+]?[0-9]+)?
nninteger := [1-9]+[0-9]*|0
</pre></div>
</div>
<p>Not all programs produced using this grammar are valid Open QASM
circuits. As explained in <a class="reference internal" href="#section-language"><span class="std std-ref">Language</span></a>, there are additional rules
concerning valid arguments, parameters, declarations, and identifiers,
as well as the standard operator precedence rules in the parameter
expressions.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="citation">
<dt class="label" id="bako05"><span class="brackets"><a class="fn-backref" href="#id27">BaKO05</a></span></dt>
<dd><p>Balensiefer, S., L. Kreger-Stickles, and M. Oskin. 2005. “QUALE: Quantum
Architecture Layout Evaluator.” <em>Proc. SPIE 5815, Quantum Information
and Computation III</em>, no. 103.</p>
</dd>
<dt class="label" id="bbcd95"><span class="brackets"><a class="fn-backref" href="#id29">BBCD95</a></span></dt>
<dd><p>Barenco, A., C. Bennett, R. Cleve, D. DiVincenzo, N. Margolus, P. Shor,
T. Sleator, J. Smolin, and H. Weinfurter. 1995. “Elementary Gates for
Quantum Computation.” <em>Phys. Rev. A</em> 52 (3457).</p>
</dd>
<dt class="label" id="chi16"><span class="brackets"><a class="fn-backref" href="#id19">Chi16</a></span></dt>
<dd><p>“Chisel: Constructing Hardware in a Scala Embedded Language.” 2016.
<a class="reference external" href="https://chisel.eecs.berkeley.edu/">https://chisel.eecs.berkeley.edu/</a>.</p>
</dd>
<dt class="label" id="chu05"><span class="brackets"><a class="fn-backref" href="#id24">Chu05</a></span></dt>
<dd><p>Chuang, I. 2005. “Qasm2circ.”
<a class="reference external" href="http://www.media.mit.edu/quanta/qasm2circ/">http://www.media.mit.edu/quanta/qasm2circ/</a>.</p>
</dd>
<dt class="label" id="sca16"><span class="brackets"><a class="fn-backref" href="#id8">Sca16</a></span></dt>
<dd><p>“Compilation, Analysis and Optimization Framework for the Scaffold
Quantum Programming Language.” 2016. <a class="reference external" href="https://github.com/epiqc/ScaffCC">https://github.com/epiqc/ScaffCC</a>.</p>
</dd>
<dt class="label" id="cro05"><span class="brackets"><a class="fn-backref" href="#id25">Cro05</a></span></dt>
<dd><p>Cross, A. 2005. “Qasm-Tools.”
<a class="reference external" href="http://www.media.mit.edu/quanta/quanta-web/projects/qasm-tools/">http://www.media.mit.edu/quanta/quanta-web/projects/qasm-tools/</a>.</p>
</dd>
<dt class="label" id="cdkm04"><span class="brackets">CDKM04</span><span class="fn-backref">(<a href="#id35">1</a>,<a href="#id36">2</a>)</span></dt>
<dd><p>Cuccaro, S., T. Draper, S. Kutin, and D. Moulton. 2004. “A New Quantum
Ripple-Carry Addition Circuit.” <em>ArXiv:quant-Ph/0410184</em>.</p>
</dd>
<dt class="label" id="stth16"><span class="brackets"><a class="fn-backref" href="#id12">StTH16</a></span></dt>
<dd><p>D. S. Steiger, M. Troyer, T. Häner. 2016. “ProjectQ: An Open Source
Software Framework for Quantum Computing.” <em>ArXiv:1612.08091</em>.</p>
</dd>
<dt class="label" id="dosp16"><span class="brackets">DoSP16</span><span class="fn-backref">(<a href="#id28">1</a>,<a href="#id31">2</a>)</span></dt>
<dd><p>Dousti, M., A. Shafaei, and M. Pedram. 2016. “Squash 2: A Hierarchical
Scalable Quantum Mapper Considering Ancilla Sharing.” <em>Quant. Inf.
Comp.</em> 16 ((4)).</p>
</dd>
<dt class="label" id="daku16"><span class="brackets"><a class="fn-backref" href="#id38">DaKu16</a></span></dt>
<dd><p>Draper, T., and S. Kutin. 2016.
“<span class="math notranslate nohighlight">\(\langle\mathrm{q}|\mathrm{pic}\rangle\)</span>: Quantum Circuit
Diagrams in Latex.” <a class="reference external" href="https://github.com/qpic/qpic">https://github.com/qpic/qpic</a>.</p>
</dd>
<dt class="label" id="gay06"><span class="brackets"><a class="fn-backref" href="#id2">Gay06</a></span></dt>
<dd><p>Gay, S. 2006. “Quantum Programming Languages: Survey and Bibliography.”
<em>Math. Structures in Computer Science</em> 16: 581–600.</p>
</dd>
<dt class="label" id="glrs13"><span class="brackets">GLRS13</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id22">2</a>)</span></dt>
<dd><p>Green, A. S., P. LeFanu Lumsdaine, N. J. Ross, P. Selinger, and B.
Valiron. 2013. “Quipper: A Scalable Quantum Programming Language.” <em>ACM
SIGPLAN Notices</em>, no. 48(6): 333–42.</p>
</dd>
<dt class="label" id="hsst16"><span class="brackets"><a class="fn-backref" href="#id4">HSST16</a></span></dt>
<dd><p>Häner, T., D. Steiger, K. Svore, and M. Troyer. 2016. “A Software
Methodology for Compiling Quantum Programs.” <em>Arxiv:1604.01401</em>.</p>
</dd>
<dt class="label" id="jpkh14"><span class="brackets">JPKH14</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id30">2</a>)</span></dt>
<dd><p>JavadiAbhari, A., S. Patil, D. Kudrow, J. Heckey, A. Lvov, F. Chong, and
M. Martonosi. 2014. “ScaffCC: A Framework for Compilation and Analysis
of Quantum Computing Programs.” <em>ACM International Conference on
Computing Frontiers (CF 2014)</em>.</p>
</dd>
<dt class="label" id="liq16"><span class="brackets"><a class="fn-backref" href="#id6">Liq16</a></span></dt>
<dd><p>“LIQ<span class="math notranslate nohighlight">\(Ui|\rangle\)</span>: The Language Integrated Quantum Operations
Simulator.” 2016. <a class="reference external" href="http://stationq.github.io/Liquid/">http://stationq.github.io/Liquid/</a>.</p>
</dd>
<dt class="label" id="liku13"><span class="brackets"><a class="fn-backref" href="#id18">LiKu13</a></span></dt>
<dd><p>Liu, X., and J. Kubiatowicz. 2013. “Chisel-Q: Designing Quantum Circuits
with a Scala Embedded Language.” <em>IEEE 31st International Conference on
Computer Design (ICCD)</em>.</p>
</dd>
<dt class="label" id="mer07"><span class="brackets">Mer07</span><span class="fn-backref">(<a href="#id33">1</a>,<a href="#id34">2</a>)</span></dt>
<dd><p>Mermin, N. D. 2007. <em>Quantum Computer Science</em>. Cambridge.</p>
</dd>
<dt class="label" id="nich00"><span class="brackets"><a class="fn-backref" href="#id23">NiCh00</a></span></dt>
<dd><p>Nielsen, M., and I. Chuang. 2000. <em>Quantum Computation and Quantum
Information</em>. Cambridge University Press.</p>
</dd>
<dt class="label" id="omer98"><span class="brackets"><a class="fn-backref" href="#id15">Omer98</a></span></dt>
<dd><p>Omer, B. 1998. “QCL – a Programming Language for Quantum Computers.”
<a class="reference external" href="http://tph.tuwien.ac.at/~oemer/qcl.html">http://tph.tuwien.ac.at/~oemer/qcl.html</a>.</p>
</dd>
<dt class="label" id="omer03"><span class="brackets"><a class="fn-backref" href="#id14">Omer03</a></span></dt>
<dd><p>2003. “Structured Quantum Programming.” <em>Vienna University of
Technology, Ph. D. Thesis</em>.</p>
</dd>
<dt class="label" id="prq17"><span class="brackets"><a class="fn-backref" href="#id13">PrQ17</a></span></dt>
<dd><p>“ProjectQ.” 2017. <a class="reference external" href="https://projectq.ch">https://projectq.ch</a>.</p>
</dd>
<dt class="label" id="quil17"><span class="brackets"><a class="fn-backref" href="#id21">Quil17</a></span></dt>
<dd><p>“Quil.” 2017. <a class="reference external" href="https://github.com/rigetticomputing/pyquil">https://github.com/rigetticomputing/pyquil</a>.</p>
</dd>
<dt class="label" id="sel04"><span class="brackets"><a class="fn-backref" href="#id1">Sel04</a></span></dt>
<dd><p>Selinger, P. 2004. “A Brief Survey of Quantum Programming Languages.”
<em>Proc. Seventh Int’l Symp. Functional and Logic Programming</em>, 1–6.</p>
</dd>
<dt class="label" id="schc06"><span class="brackets">SCHC06</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id26">2</a>)</span></dt>
<dd><p>Svore, K., A. Cross, A. Aho, I. Chuang, and I. Markov. 2006. “A Layered
Software Architecture for Quantum Computing Design Tools.” <em>IEEE
Computer</em>, no. 39(1): 74–83.</p>
</dd>
<dt class="label" id="smcz16"><span class="brackets"><a class="fn-backref" href="#id20">SmCZ16</a></span></dt>
<dd><p>R. Smith and M. Curtis and W. Zeng. 2016. “A Practical Quantum Instruction Set Architecture.”
<em>arXiv:1608.03355</em>.</p>
</dd>
<dt class="label" id="iqe16"><span class="brackets"><a class="fn-backref" href="#id37">IQE16</a></span></dt>
<dd><p>“The IBM Quantum Experience.” 2016.
<a class="reference external" href="http://www.research.ibm.com/quantum/">http://www.research.ibm.com/quantum/</a>.</p>
</dd>
<dt class="label" id="qui13"><span class="brackets"><a class="fn-backref" href="#id11">Qui13</a></span></dt>
<dd><p>“The Quipper Language.” 2013.
<a class="reference external" href="http://www.mathstat.dal.ca/~selinger/quipper/">http://www.mathstat.dal.ca/~selinger/quipper/</a>.</p>
</dd>
<dt class="label" id="vrss15"><span class="brackets"><a class="fn-backref" href="#id9">VRSS15</a></span></dt>
<dd><p>Valiron, B., N. Ross, P. Selinger, D. Scott Alexander, and J. Smith.
2015. “Programming the Quantum Future.” <em>Communications of the ACM</em> 58
(8): 52–61.</p>
</dd>
<dt class="label" id="vimh05"><span class="brackets"><a class="fn-backref" href="#id17">ViMH05</a></span></dt>
<dd><p>Viamontes, G. F., I. L. Markov, and J. P. Hayes. 2005. “Graph-Based
Simulation of Quantum Computation in the Density Matrix Representation.”
<em>Quant. Inf. Comp.</em> 5 (2): 113–30.</p>
</dd>
<dt class="label" id="vgmh04"><span class="brackets"><a class="fn-backref" href="#id16">VGMH04</a></span></dt>
<dd><p>Viamontes, G., H. Garcia, I. Markov, and J. Hayes. 2004. “QuIDDPro:
High-Performance Quantum Circuit Simulation.”
<a class="reference external" href="http://vlsicad.eecs.umich.edu/Quantum/qp/">http://vlsicad.eecs.umich.edu/Quantum/qp/</a>.</p>
</dd>
<dt class="label" id="wesv14"><span class="brackets"><a class="fn-backref" href="#id5">WeSv14</a></span></dt>
<dd><p>Wecker, D., and K. Svore. 2014. “LIQ<span class="math notranslate nohighlight">\(Ui|\rangle\)</span>: A Software
Design Architecture and Domain-Specific Language for Quantum Computing.”
<em>ArXiv:1402.4467</em>.</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id39"><span class="brackets"><a class="fn-backref" href="#id32">1</a></span></dt>
<dd><p>Features include scientific notation; real arithmetic; logarithmic,
trigonometic, and exponential functions; square roots; and the
built-in constant <span class="math notranslate nohighlight">\(\pi\)</span>. The Quantum Experience uses a double
precision floating point type for real numbers.</p>
</dd>
</dl>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">OpenQASM Live Specification</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2020, Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>